#lang racket
(require parser-tools/lex)(define(lexer Instructions)(define symbols '())(for ([line Instructions])(define InstructionT (string-split line))(define opCodeSequenceT '())(define switch #f)(for ([tok InstructionT])(cond
[(equal? (substring tok 0)"(")(define tf(substring tok 0 1))(define enz(substring tok 1))(set! switch #t)(set! opCodeSequenceT (append (list enz tf) opCodeSequenceT))][(equal? (substring tok (- (string-length tok) 1) (string-length tok)) ")")
(define tf (substring tok (-(string-length tok)2) (-(string-length tok)1)))(define enz (substring tok (- (string-length tok) 1) (string-length tok)))(set! opCodeSequenceT (append (list enz tf) opCodeSequenceT))
(set! switch #t)][else(set! opCodeSequenceT (cons tok opCodeSequenceT))]))(cond[(equal? switch #t)(set! symbols (cons (reverse opCodeSequenceT) symbols))][else(set! symbols (cons (reverse opCodeSequenceT) symbols))]
))(set! symbols (reverse symbols))symbols)(define (Instructionlist programSteps)(define line# void)(cond[(empty? programSteps)][else (set! line# (first (first programSteps)))(cond[(equal? (line (first programSteps)) #t)
(Instructionlist (rest programSteps))][(equal? programSteps (list(list "$$")))(println "Accept :)")][else(cond[(equal? (linenum line#) #f)(printf "Oh no, error @ line # missing at ~s"(first programSteps))]
[else (printf "Oh no, error @ line # ~s ~s"line#(first programSteps))])])]))(define (tokenizer unit)(cond[(equal? unit "=") 'ASSIGN][(equal? unit "+") 'ADD][(equal? unit "-") 'SUBCTRACT][(equal? unit "0") 'ZERO][(equal? unit ":") 'COL]
[(equal? unit "(") 'OP][(equal? unit ")") 'CLO][(equal? unit "write") 'W][(equal? unit "read") 'R][(equal? unit "goto") 'GOTO][(equal? unit "gosub") 'GOSUB][(equal? unit "return") 'RE][(equal? unit "if") 'IF][(equal? unit "then") 'THEN]
[(equal? unit "$$") 'EOF][(equal? (linenum unit) #t) 'LINENUM][(equal? (id unit) #t) 'ID][else 'UN]))(define (linenum token)(define tokenMapper (string->number token 10 'number-or-false))(cond[(and (number? tokenMapper)(< 0 tokenMapper))#t]
[else #f]))(define (id unit)(define tokenMapper (string->number unit 10 'number-or-false))(cond[(char-alphabetic? (string-ref unit 0))#t][(void? unit)#f][(not (equal? tokenMapper #f))#f]))(define (line lineunit)
(let([ized (map tokenizer lineunit)])(cond[(and (equal? (first ized) 'LINENUM)(equal? (stmt (rest ized)) #t))#t][else #f])))(define (stmt symbols)(cond[(equal? (first symbols) 'ID)(cond[(equal? (second symbols) 'ASSIGN)(ex (rest(rest symbols)))])]
[(equal? (first symbols) 'GOTO)(cond[(equal? (second symbols) 'LINENUM)])#t][(equal? (first symbols) 'GOSUB)(cond[(equal? (second symbols) 'LINENUM)])#t][(equal? (first symbols)'R)(cond[(equal? (second symbols) 'ID)#t])][(equal? (first symbols) 'W)(cond
[(list? symbols)(and (equal? (second symbols) 'ID)(equal? (et (rest (rest symbols))) #f))#t][(equal? (et (rest (rest symbols)))#t)#t][else #f])][(equal? (first symbols)'RE)#t][(equal? (first symbols)'IF)(cond[(equal? (ex (rest symbols)) #t)
(cond[(equal? (stmt (rest (member 'THEN symbols)))#t)#t])])]))(define(ex symbols)(cond[(or (equal? (first symbols) 'LINENUM)(equal? (first symbols)'ZERO))(cond[(=(length symbols)1)#t][(equal? (second symbols) 'THEN)#t][else (et (rest symbols))])]
[(equal? (first symbols)'ID)(et (rest symbols))][(equal? (first symbols)'OP)(cond[(and (equal? (ex (rest symbols)) #t)(equal? (last symbols) 'CLO))#t])][else #f]))(define (et symbols)(cond[(and (list? symbols)(not (empty? symbols)))(cond
[(equal? (last symbols)'CLO)#t][(or (equal? (first symbols) 'ADD)(equal? (first symbols) 'SUBCTRACT)(equal? (first symbols) 'ASSIGN))(cond[(equal? (ex (rest symbols)) #t)#t])][(equal? (first symbols)'COL)(EOLMarker (rest symbols))]
[(equal? (first symbols)'CLO)#t][(equal? (first symbols)'UN)#f][else #f])]))(define (EOLMarker symbols)(cond[(equal? (stmt symbols) #t)#t]))(define (parse document)(program document))(define (program document)(define inputInstructions
(file->lines document))(define programSteps (lexer inputInstructions))(Instructionlist programSteps))